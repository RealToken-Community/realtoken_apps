import 'package:flutter/material.dart';
import 'package:hive/hive.dart';
import '../models/balance_record.dart';
import '../models/roi_record.dart';
import '../models/apy_record.dart';
import '../models/healthandltv_record.dart';
import '../models/rented_record.dart';
import 'data_manager.dart';
import 'dart:convert';

class ArchiveManager {
  static final ArchiveManager _instance = ArchiveManager._internal();
  factory ArchiveManager() => _instance;
  ArchiveManager._internal();

  DataManager? _dataManager;

  void setDataManager(DataManager dataManager) {
    _dataManager = dataManager;
  }

  DateTime? lastArchiveTime;

  Future<void> archiveTotalWalletValue(double totalWalletValue) async {
    debugPrint("üìä D√©but de l'archivage totalWalletValue");

    // 1. D'abord, lire les donn√©es existantes dans balanceHistory
    var boxBalance = Hive.box('balanceHistory');
    List<dynamic>? balanceHistoryJson =
        boxBalance.get('balanceHistory_totalWalletValue');
    List<BalanceRecord> balanceHistory = balanceHistoryJson != null
        ? balanceHistoryJson
            .map((recordJson) =>
                BalanceRecord.fromJson(Map<String, dynamic>.from(recordJson)))
            .toList()
        : [];

    debugPrint(
        "üìä Historique balanceHistory: ${balanceHistory.length} enregistrements");

    // 2. Ensuite, lire les donn√©es existantes dans walletValueArchive
    var boxWalletValue = Hive.box('walletValueArchive');
    List<dynamic>? walletValueArchiveJson =
        boxWalletValue.get('balanceHistory_totalWalletValue');
    List<BalanceRecord> walletValueArchive = walletValueArchiveJson != null
        ? walletValueArchiveJson
            .map((recordJson) =>
                BalanceRecord.fromJson(Map<String, dynamic>.from(recordJson)))
            .toList()
        : [];

    debugPrint(
        "üìä Historique walletValueArchive: ${walletValueArchive.length} enregistrements");

    // Si l'historique existe, v√©rifier si on doit ajouter un nouvel enregistrement
    if (balanceHistory.isNotEmpty) {
      BalanceRecord lastRecord = balanceHistory.last;
      DateTime lastTimestamp = lastRecord.timestamp;

      if (DateTime.now().difference(lastTimestamp).inHours < 1) {
        debugPrint(
            "‚è±Ô∏è Derni√®re archive trop r√©cente (< 1h), aucun nouvel enregistrement ajout√©");
        return;
      }
    }

    // Cr√©er un nouvel enregistrement
    BalanceRecord newRecord = BalanceRecord(
      tokenType: 'totalWalletValue',
      balance: double.parse(totalWalletValue.toStringAsFixed(3)),
      timestamp: DateTime.now(),
    );

    // Ajouter le nouvel enregistrement aux deux listes
    balanceHistory.add(newRecord);

    // S'assurer que walletValueArchive contient tous les enregistrements de balanceHistory
    // Pour cela, on r√©initialise walletValueArchive avec le contenu de balanceHistory
    walletValueArchive = List.from(balanceHistory);

    // Maintenant sauvegarder les deux listes
    List<Map<String, dynamic>> balanceHistoryJsonToSave =
        balanceHistory.map((record) => record.toJson()).toList();

    List<Map<String, dynamic>> walletValueArchiveJsonToSave =
        walletValueArchive.map((record) => record.toJson()).toList();

    // Sauvegarder dans les deux bo√Ætes Hive
    await boxBalance.put(
        'balanceHistory_totalWalletValue', balanceHistoryJsonToSave);
    await boxWalletValue.put(
        'balanceHistory_totalWalletValue', walletValueArchiveJsonToSave);

    debugPrint(
        "‚úÖ Archivage termin√© - Nouvel enregistrement ajout√©, total: ${balanceHistory.length} enregistrements");
  }

  Future<void> archiveRentedValue(double rentedValue) async {
    try {
      var box = Hive.box('rentedArchive');

      List<dynamic>? rentedHistoryJson = box.get('rented_history');
      List<RentedRecord> rentedHistory = rentedHistoryJson != null
          ? rentedHistoryJson
              .map((recordJson) =>
                  RentedRecord.fromJson(Map<String, dynamic>.from(recordJson)))
              .toList()
          : [];

      if (rentedHistory.isNotEmpty) {
        RentedRecord lastRecord = rentedHistory.last;
        DateTime lastTimestamp = lastRecord.timestamp;

        if (DateTime.now().difference(lastTimestamp).inHours < 1) {
          debugPrint(
              'Derni√®re archive r√©cente, aucun nouvel enregistrement ajout√©.');
          return;
        }
      }

      RentedRecord newRecord = RentedRecord(
        percentage: double.parse(rentedValue.toStringAsFixed(3)),
        timestamp: DateTime.now(),
      );
      rentedHistory.add(newRecord);

      List<Map<String, dynamic>> rentedHistoryJsonToSave =
          rentedHistory.map((record) => record.toJson()).toList();
      await box.put('rented_history', rentedHistoryJsonToSave);
      debugPrint('Nouvel enregistrement ROI ajout√© et sauvegard√© avec succ√®s.');
    } catch (e) {
      debugPrint('Erreur lors de l\'archivage de la valeur ROI : $e');
    }
  }

  Future<void> archiveRoiValue(double roiValue) async {
    debugPrint(
        "üóÉÔ∏è D√©but archivage ROI: valeur=${roiValue.toStringAsFixed(3)}%");
    try {
      debugPrint(
          'üóÉÔ∏è D√©but archivage ROI: valeur=${roiValue.toStringAsFixed(3)}%');
      var box = Hive.box('roiValueArchive');

      List<dynamic>? roiHistoryJson = box.get('roi_history');

      // V√©rifier si les donn√©es sont nulles et initialiser avec une liste vide si n√©cessaire
      if (roiHistoryJson == null) {
        debugPrint(
            'üóÉÔ∏è ROI: Aucun historique trouv√©, initialisation d\'une nouvelle liste');
        roiHistoryJson = [];
      } else {
        debugPrint(
            'üóÉÔ∏è ROI: Historique existant trouv√© avec ${roiHistoryJson.length} entr√©es');
      }

      List<ROIRecord> roiHistory = roiHistoryJson
          .map((recordJson) =>
              ROIRecord.fromJson(Map<String, dynamic>.from(recordJson)))
          .toList();

      if (roiHistory.isNotEmpty) {
        ROIRecord lastRecord = roiHistory.last;
        DateTime lastTimestamp = lastRecord.timestamp;
        Duration timeSinceLastRecord = DateTime.now().difference(lastTimestamp);

        debugPrint(
            'üóÉÔ∏è ROI: Dernier enregistrement du ${lastTimestamp.toIso8601String()} (il y a ${timeSinceLastRecord.inHours}h)');

        if (timeSinceLastRecord.inHours < 1) {
          debugPrint(
              'üóÉÔ∏è ROI: Derni√®re archive trop r√©cente (<1h), aucun nouvel enregistrement ajout√©');
          return;
        }
      } else {
        debugPrint('üóÉÔ∏è ROI: Aucun enregistrement existant');
      }

      ROIRecord newRecord = ROIRecord(
        roi: double.parse(roiValue.toStringAsFixed(3)),
        timestamp: DateTime.now(),
      );
      roiHistory.add(newRecord);

      List<Map<String, dynamic>> roiHistoryJsonToSave =
          roiHistory.map((record) => record.toJson()).toList();
      await box.put('roi_history', roiHistoryJsonToSave);
      debugPrint(
          'üóÉÔ∏è ROI: Nouvel enregistrement ajout√© avec succ√®s, total: ${roiHistory.length} enregistrements');

      // Afficher quelques enregistrements pour le d√©bogage
      if (roiHistory.isNotEmpty) {
        debugPrint(
            'üóÉÔ∏è ROI: Dernier enregistrement: ${roiHistory.last.roi}% (${roiHistory.last.timestamp.toIso8601String()})');
      }
      if (roiHistory.length > 1) {
        debugPrint(
            'üóÉÔ∏è ROI: Avant-dernier enregistrement: ${roiHistory[roiHistory.length - 2].roi}% (${roiHistory[roiHistory.length - 2].timestamp.toIso8601String()})');
      }
    } catch (e) {
      debugPrint('‚ùå Erreur lors de l\'archivage de la valeur ROI : $e');
    }
  }

  Future<void> archiveApyValue(double netApyValue, double grossApyValue) async {
    try {
      // Utiliser la bo√Æte correcte qui est ouverte dans main.dart
      var box = Hive.box('apyValueArchive');

      List<dynamic>? apyHistoryJson = box.get('apy_history');
      List<APYRecord> apyHistory = [];

      // Chargement robuste des donn√©es existantes
      if (apyHistoryJson != null) {
        for (var recordJson in apyHistoryJson) {
          try {
            // S'assurer que recordJson est bien un Map
            Map<String, dynamic> recordMap;
            if (recordJson is Map<String, dynamic>) {
              recordMap = recordJson;
            } else if (recordJson is Map) {
              recordMap = Map<String, dynamic>.from(recordJson);
            } else {
              debugPrint(
                  "‚ö†Ô∏è Enregistrement APY ignor√© (format invalide): $recordJson");
              continue;
            }

            // Cr√©er l'APYRecord avec gestion d'erreur
            final apyRecord = APYRecord.fromJson(recordMap);
            apyHistory.add(apyRecord);
          } catch (e) {
            debugPrint(
                "‚ö†Ô∏è Erreur lors du d√©codage d'un enregistrement APY: $e");
            debugPrint("üìÑ Donn√©es probl√©matiques: $recordJson");
            continue; // Ignorer cet enregistrement et continuer
          }
        }
      }

      // Cr√©er le nouvel enregistrement avec timestamp actuel
      final now = DateTime.now();
      final newRecord = APYRecord.fromLegacy(
        timestamp: now,
        netApy: netApyValue,
        grossApy: grossApyValue,
      );

      // Ajouter le nouvel enregistrement
      apyHistory.add(newRecord);

      // Trier par timestamp pour maintenir l'ordre chronologique
      apyHistory.sort((a, b) => a.timestamp.compareTo(b.timestamp));

      // Convertir en JSON avec gestion s√©curis√©e
      final apyHistoryJsonList = apyHistory
          .map((record) {
            try {
              return record.toJson();
            } catch (e) {
              debugPrint(
                  "‚ö†Ô∏è Erreur lors de la conversion JSON d'un enregistrement APY: $e");
              return null;
            }
          })
          .where((json) => json != null)
          .toList();

      // Sauvegarder dans la bo√Æte Hive
      await box.put('apy_history', apyHistoryJsonList);

      // Marquer la derni√®re mise √† jour
      await box.put('lastApyArchiveTime', now.toIso8601String());

      debugPrint(
          "‚úÖ Valeur APY archiv√©e avec succ√®s: Net $netApyValue%, Gross $grossApyValue%");
      debugPrint(
          "üìä Total des enregistrements APY: ${apyHistoryJsonList.length}");
    } catch (e) {
      debugPrint("‚ùå Erreur lors de l'archivage des valeurs APY : $e");
      rethrow; // Relancer l'erreur pour que le code appelant puisse la g√©rer
    }
  }

  Future<void> archiveBalance(
      String tokenType, double balance, String timestamp) async {
    try {
      var box = Hive.box('balanceHistory');

      dynamic rawData = box.get('balanceHistory_$tokenType');
      List<BalanceRecord> balanceHistory = [];

      if (rawData != null) {
        if (rawData is List) {
          balanceHistory = rawData
              .map((recordJson) =>
                  BalanceRecord.fromJson(Map<String, dynamic>.from(recordJson)))
              .toList();
        } else if (rawData is String) {
          // Si les donn√©es sont une cha√Æne JSON, on essaie de les parser
          try {
            List<dynamic> parsedData = json.decode(rawData);
            balanceHistory = parsedData
                .map((recordJson) => BalanceRecord.fromJson(
                    Map<String, dynamic>.from(recordJson)))
                .toList();
          } catch (e) {
            debugPrint(
                "‚ö†Ô∏è Erreur lors du parsing des donn√©es JSON pour $tokenType: $e");
          }
        }
      }

      // Conversion s√©curis√©e de la date
      DateTime parsedTimestamp;
      try {
        parsedTimestamp = DateTime.parse(timestamp);
      } catch (e) {
        debugPrint(
            "‚ö†Ô∏è Format de timestamp invalide '$timestamp', utilisation de l'heure actuelle: $e");
        parsedTimestamp = DateTime.now();
      }

      BalanceRecord newRecord = BalanceRecord(
        tokenType: tokenType,
        balance: double.parse(balance.toStringAsFixed(3)),
        timestamp: parsedTimestamp,
      );

      balanceHistory.add(newRecord);

      List<Map<String, dynamic>> balanceHistoryJsonToSave =
          balanceHistory.map((record) => record.toJson()).toList();
      await box.put('balanceHistory_$tokenType', balanceHistoryJsonToSave);

      debugPrint(
          "üìä Archivage de la balance - Token: $tokenType, Balance: ${balance.toStringAsFixed(3)}, Timestamp: ${parsedTimestamp.toIso8601String()}");
    } catch (e) {
      debugPrint(
          '‚ùå Erreur lors de l\'archivage de la balance pour $tokenType : $e');
      debugPrint('Stack trace: ${StackTrace.current}');
    }
  }

  Future<void> archiveHealthAndLtvValue(
      double healtFactorValue, double ltvValue) async {
    try {
      var box = Hive.box('HealthAndLtvValueArchive');

      List<dynamic>? healthAndLtvHistoryJson = box.get('healthAndLtv_history');
      List<HealthAndLtvRecord> healthAndLtvHistory =
          healthAndLtvHistoryJson != null
              ? healthAndLtvHistoryJson
                  .map((recordJson) => HealthAndLtvRecord.fromJson(
                      Map<String, dynamic>.from(recordJson)))
                  .toList()
              : [];

      if (healthAndLtvHistory.isNotEmpty) {
        HealthAndLtvRecord lastRecord = healthAndLtvHistory.last;
        DateTime lastTimestamp = lastRecord.timestamp;

        if (DateTime.now().difference(lastTimestamp).inHours < 1) {
          debugPrint(
              'Dernier enregistrement r√©cent, aucun nouvel enregistrement ajout√©.');
          return;
        }
      }

      HealthAndLtvRecord newRecord = HealthAndLtvRecord(
        healthFactor: double.parse(healtFactorValue.toStringAsFixed(3)),
        ltv: double.parse(ltvValue.toStringAsFixed(3)),
        timestamp: DateTime.now(),
      );
      healthAndLtvHistory.add(newRecord);

      List<Map<String, dynamic>> healthAndLtvHistoryJsonToSave =
          healthAndLtvHistory.map((record) => record.toJson()).toList();
      await box.put('healthAndLtv_history', healthAndLtvHistoryJsonToSave);

      debugPrint('Nouvel enregistrement APY ajout√© et sauvegard√© avec succ√®s.');
    } catch (e) {
      debugPrint('Erreur lors de l\'archivage des valeurs APY : $e');
    }
  }

  Future<List<BalanceRecord>> getBalanceHistory(String tokenType) async {
    var box = Hive.box('balanceHistory');

    List<dynamic>? balanceHistoryJson = box.get('balanceHistory_$tokenType');
    return balanceHistoryJson!
        .map((recordJson) =>
            BalanceRecord.fromJson(Map<String, dynamic>.from(recordJson)))
        .where((record) => record.tokenType == tokenType)
        .toList();
  }

  /// Archive la valeur de loyer actuelle
  Future<void> archiveRentValue(double percentage) async {
    // V√©rifier si la bo√Æte est ouverte ou l'ouvrir si n√©cessaire
    if (!Hive.isBoxOpen('rentData')) {
      await Hive.openBox('rentData');
    }
    var box = Hive.box('rentData');

    final timestamp = DateTime.now();

    // Cr√©er un nouvel enregistrement RentRecord
    final rentRecord = RentedRecord(
      percentage: percentage,
      timestamp: timestamp,
    );

    // R√©cup√©rer les donn√©es existantes
    List<dynamic> existingData = box.get('rentHistory', defaultValue: []);
    List<Map<String, dynamic>> rentHistory =
        List<Map<String, dynamic>>.from(existingData);

    // Calculer le temps √©coul√© depuis le dernier enregistrement
    bool shouldArchive = rentHistory.isEmpty;
    if (!shouldArchive && rentHistory.isNotEmpty) {
      final lastRecord = RentedRecord.fromJson(rentHistory.last);
      final daysSinceLastRecord =
          timestamp.difference(lastRecord.timestamp).inDays;

      // D√©terminer si l'archivage doit avoir lieu en fonction du nombre d'enregistrements
      if (rentHistory.length < 30) {
        // Moins de 30 enregistrements, archiver quotidiennement
        shouldArchive = daysSinceLastRecord >= 1;
      } else if (rentHistory.length < 90) {
        // Entre 30 et 90 enregistrements, archiver tous les 3 jours
        shouldArchive = daysSinceLastRecord >= 3;
      } else if (rentHistory.length < 180) {
        // Entre 90 et 180 enregistrements, archiver chaque semaine
        shouldArchive = daysSinceLastRecord >= 7;
      } else {
        // Plus de 180 enregistrements, archiver tous les 15 jours
        shouldArchive = daysSinceLastRecord >= 15;
      }
    }

    // Archiver la valeur si n√©cessaire
    if (shouldArchive) {
      // debugPrint("üìä Archivage de la valeur de loyer: $rent, cumulatif: $cumulativeRent");
      rentHistory.add(rentRecord.toJson());
      await box.put('rentHistory', rentHistory);
    }
  }
}
